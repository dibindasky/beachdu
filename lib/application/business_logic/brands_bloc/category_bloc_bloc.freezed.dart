// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'category_bloc_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CategoryBlocEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CategoryBlocEventCopyWith<$Res> {
  factory $CategoryBlocEventCopyWith(
          CategoryBlocEvent value, $Res Function(CategoryBlocEvent) then) =
      _$CategoryBlocEventCopyWithImpl<$Res, CategoryBlocEvent>;
}

/// @nodoc
class _$CategoryBlocEventCopyWithImpl<$Res, $Val extends CategoryBlocEvent>
    implements $CategoryBlocEventCopyWith<$Res> {
  _$CategoryBlocEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetAllCategoryImplCopyWith<$Res> {
  factory _$$GetAllCategoryImplCopyWith(_$GetAllCategoryImpl value,
          $Res Function(_$GetAllCategoryImpl) then) =
      __$$GetAllCategoryImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetAllCategoryImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$GetAllCategoryImpl>
    implements _$$GetAllCategoryImplCopyWith<$Res> {
  __$$GetAllCategoryImplCopyWithImpl(
      _$GetAllCategoryImpl _value, $Res Function(_$GetAllCategoryImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetAllCategoryImpl
    with DiagnosticableTreeMixin
    implements GetAllCategory {
  const _$GetAllCategoryImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.getAllCategory()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'CategoryBlocEvent.getAllCategory'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetAllCategoryImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return getAllCategory();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return getAllCategory?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (getAllCategory != null) {
      return getAllCategory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return getAllCategory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return getAllCategory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (getAllCategory != null) {
      return getAllCategory(this);
    }
    return orElse();
  }
}

abstract class GetAllCategory implements CategoryBlocEvent {
  const factory GetAllCategory() = _$GetAllCategoryImpl;
}

/// @nodoc
abstract class _$$GetSingleCategoryBrandsImplCopyWith<$Res> {
  factory _$$GetSingleCategoryBrandsImplCopyWith(
          _$GetSingleCategoryBrandsImpl value,
          $Res Function(_$GetSingleCategoryBrandsImpl) then) =
      __$$GetSingleCategoryBrandsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isLoad, String? categoryType});
}

/// @nodoc
class __$$GetSingleCategoryBrandsImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$GetSingleCategoryBrandsImpl>
    implements _$$GetSingleCategoryBrandsImplCopyWith<$Res> {
  __$$GetSingleCategoryBrandsImplCopyWithImpl(
      _$GetSingleCategoryBrandsImpl _value,
      $Res Function(_$GetSingleCategoryBrandsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoad = null,
    Object? categoryType = freezed,
  }) {
    return _then(_$GetSingleCategoryBrandsImpl(
      isLoad: null == isLoad
          ? _value.isLoad
          : isLoad // ignore: cast_nullable_to_non_nullable
              as bool,
      categoryType: freezed == categoryType
          ? _value.categoryType
          : categoryType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$GetSingleCategoryBrandsImpl
    with DiagnosticableTreeMixin
    implements GetSingleCategoryBrands {
  const _$GetSingleCategoryBrandsImpl(
      {required this.isLoad, this.categoryType});

  @override
  final bool isLoad;
  @override
  final String? categoryType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.getSingleCategoryBrands(isLoad: $isLoad, categoryType: $categoryType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'CategoryBlocEvent.getSingleCategoryBrands'))
      ..add(DiagnosticsProperty('isLoad', isLoad))
      ..add(DiagnosticsProperty('categoryType', categoryType));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetSingleCategoryBrandsImpl &&
            (identical(other.isLoad, isLoad) || other.isLoad == isLoad) &&
            (identical(other.categoryType, categoryType) ||
                other.categoryType == categoryType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isLoad, categoryType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetSingleCategoryBrandsImplCopyWith<_$GetSingleCategoryBrandsImpl>
      get copyWith => __$$GetSingleCategoryBrandsImplCopyWithImpl<
          _$GetSingleCategoryBrandsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return getSingleCategoryBrands(isLoad, categoryType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return getSingleCategoryBrands?.call(isLoad, categoryType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (getSingleCategoryBrands != null) {
      return getSingleCategoryBrands(isLoad, categoryType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return getSingleCategoryBrands(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return getSingleCategoryBrands?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (getSingleCategoryBrands != null) {
      return getSingleCategoryBrands(this);
    }
    return orElse();
  }
}

abstract class GetSingleCategoryBrands implements CategoryBlocEvent {
  const factory GetSingleCategoryBrands(
      {required final bool isLoad,
      final String? categoryType}) = _$GetSingleCategoryBrandsImpl;

  bool get isLoad;
  String? get categoryType;
  @JsonKey(ignore: true)
  _$$GetSingleCategoryBrandsImplCopyWith<_$GetSingleCategoryBrandsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BrandSearchImplCopyWith<$Res> {
  factory _$$BrandSearchImplCopyWith(
          _$BrandSearchImpl value, $Res Function(_$BrandSearchImpl) then) =
      __$$BrandSearchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String searchQuery});
}

/// @nodoc
class __$$BrandSearchImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$BrandSearchImpl>
    implements _$$BrandSearchImplCopyWith<$Res> {
  __$$BrandSearchImplCopyWithImpl(
      _$BrandSearchImpl _value, $Res Function(_$BrandSearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? searchQuery = null,
  }) {
    return _then(_$BrandSearchImpl(
      searchQuery: null == searchQuery
          ? _value.searchQuery
          : searchQuery // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BrandSearchImpl with DiagnosticableTreeMixin implements BrandSearch {
  const _$BrandSearchImpl({required this.searchQuery});

  @override
  final String searchQuery;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.brandSearch(searchQuery: $searchQuery)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocEvent.brandSearch'))
      ..add(DiagnosticsProperty('searchQuery', searchQuery));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BrandSearchImpl &&
            (identical(other.searchQuery, searchQuery) ||
                other.searchQuery == searchQuery));
  }

  @override
  int get hashCode => Object.hash(runtimeType, searchQuery);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BrandSearchImplCopyWith<_$BrandSearchImpl> get copyWith =>
      __$$BrandSearchImplCopyWithImpl<_$BrandSearchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return brandSearch(searchQuery);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return brandSearch?.call(searchQuery);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (brandSearch != null) {
      return brandSearch(searchQuery);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return brandSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return brandSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (brandSearch != null) {
      return brandSearch(this);
    }
    return orElse();
  }
}

abstract class BrandSearch implements CategoryBlocEvent {
  const factory BrandSearch({required final String searchQuery}) =
      _$BrandSearchImpl;

  String get searchQuery;
  @JsonKey(ignore: true)
  _$$BrandSearchImplCopyWith<_$BrandSearchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SeriesSearchImplCopyWith<$Res> {
  factory _$$SeriesSearchImplCopyWith(
          _$SeriesSearchImpl value, $Res Function(_$SeriesSearchImpl) then) =
      __$$SeriesSearchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String searchQuery});
}

/// @nodoc
class __$$SeriesSearchImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$SeriesSearchImpl>
    implements _$$SeriesSearchImplCopyWith<$Res> {
  __$$SeriesSearchImplCopyWithImpl(
      _$SeriesSearchImpl _value, $Res Function(_$SeriesSearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? searchQuery = null,
  }) {
    return _then(_$SeriesSearchImpl(
      searchQuery: null == searchQuery
          ? _value.searchQuery
          : searchQuery // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SeriesSearchImpl with DiagnosticableTreeMixin implements SeriesSearch {
  const _$SeriesSearchImpl({required this.searchQuery});

  @override
  final String searchQuery;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.seriesSearch(searchQuery: $searchQuery)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocEvent.seriesSearch'))
      ..add(DiagnosticsProperty('searchQuery', searchQuery));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SeriesSearchImpl &&
            (identical(other.searchQuery, searchQuery) ||
                other.searchQuery == searchQuery));
  }

  @override
  int get hashCode => Object.hash(runtimeType, searchQuery);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SeriesSearchImplCopyWith<_$SeriesSearchImpl> get copyWith =>
      __$$SeriesSearchImplCopyWithImpl<_$SeriesSearchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return seriesSearch(searchQuery);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return seriesSearch?.call(searchQuery);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (seriesSearch != null) {
      return seriesSearch(searchQuery);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return seriesSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return seriesSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (seriesSearch != null) {
      return seriesSearch(this);
    }
    return orElse();
  }
}

abstract class SeriesSearch implements CategoryBlocEvent {
  const factory SeriesSearch({required final String searchQuery}) =
      _$SeriesSearchImpl;

  String get searchQuery;
  @JsonKey(ignore: true)
  _$$SeriesSearchImplCopyWith<_$SeriesSearchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetProductsImplCopyWith<$Res> {
  factory _$$GetProductsImplCopyWith(
          _$GetProductsImpl value, $Res Function(_$GetProductsImpl) then) =
      __$$GetProductsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String categoryType, String brandName, String seriesName});
}

/// @nodoc
class __$$GetProductsImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$GetProductsImpl>
    implements _$$GetProductsImplCopyWith<$Res> {
  __$$GetProductsImplCopyWithImpl(
      _$GetProductsImpl _value, $Res Function(_$GetProductsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? categoryType = null,
    Object? brandName = null,
    Object? seriesName = null,
  }) {
    return _then(_$GetProductsImpl(
      categoryType: null == categoryType
          ? _value.categoryType
          : categoryType // ignore: cast_nullable_to_non_nullable
              as String,
      brandName: null == brandName
          ? _value.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String,
      seriesName: null == seriesName
          ? _value.seriesName
          : seriesName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetProductsImpl with DiagnosticableTreeMixin implements GetProducts {
  const _$GetProductsImpl(
      {required this.categoryType,
      required this.brandName,
      required this.seriesName});

  @override
  final String categoryType;
  @override
  final String brandName;
  @override
  final String seriesName;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.getProducts(categoryType: $categoryType, brandName: $brandName, seriesName: $seriesName)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocEvent.getProducts'))
      ..add(DiagnosticsProperty('categoryType', categoryType))
      ..add(DiagnosticsProperty('brandName', brandName))
      ..add(DiagnosticsProperty('seriesName', seriesName));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetProductsImpl &&
            (identical(other.categoryType, categoryType) ||
                other.categoryType == categoryType) &&
            (identical(other.brandName, brandName) ||
                other.brandName == brandName) &&
            (identical(other.seriesName, seriesName) ||
                other.seriesName == seriesName));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, categoryType, brandName, seriesName);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetProductsImplCopyWith<_$GetProductsImpl> get copyWith =>
      __$$GetProductsImplCopyWithImpl<_$GetProductsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return getProducts(categoryType, brandName, seriesName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return getProducts?.call(categoryType, brandName, seriesName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (getProducts != null) {
      return getProducts(categoryType, brandName, seriesName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return getProducts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return getProducts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (getProducts != null) {
      return getProducts(this);
    }
    return orElse();
  }
}

abstract class GetProducts implements CategoryBlocEvent {
  const factory GetProducts(
      {required final String categoryType,
      required final String brandName,
      required final String seriesName}) = _$GetProductsImpl;

  String get categoryType;
  String get brandName;
  String get seriesName;
  @JsonKey(ignore: true)
  _$$GetProductsImplCopyWith<_$GetProductsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ProductSearchImplCopyWith<$Res> {
  factory _$$ProductSearchImplCopyWith(
          _$ProductSearchImpl value, $Res Function(_$ProductSearchImpl) then) =
      __$$ProductSearchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String searchQuery});
}

/// @nodoc
class __$$ProductSearchImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$ProductSearchImpl>
    implements _$$ProductSearchImplCopyWith<$Res> {
  __$$ProductSearchImplCopyWithImpl(
      _$ProductSearchImpl _value, $Res Function(_$ProductSearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? searchQuery = null,
  }) {
    return _then(_$ProductSearchImpl(
      searchQuery: null == searchQuery
          ? _value.searchQuery
          : searchQuery // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ProductSearchImpl
    with DiagnosticableTreeMixin
    implements ProductSearch {
  const _$ProductSearchImpl({required this.searchQuery});

  @override
  final String searchQuery;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.productSearch(searchQuery: $searchQuery)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocEvent.productSearch'))
      ..add(DiagnosticsProperty('searchQuery', searchQuery));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductSearchImpl &&
            (identical(other.searchQuery, searchQuery) ||
                other.searchQuery == searchQuery));
  }

  @override
  int get hashCode => Object.hash(runtimeType, searchQuery);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductSearchImplCopyWith<_$ProductSearchImpl> get copyWith =>
      __$$ProductSearchImplCopyWithImpl<_$ProductSearchImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return productSearch(searchQuery);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return productSearch?.call(searchQuery);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (productSearch != null) {
      return productSearch(searchQuery);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return productSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return productSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (productSearch != null) {
      return productSearch(this);
    }
    return orElse();
  }
}

abstract class ProductSearch implements CategoryBlocEvent {
  const factory ProductSearch({required final String searchQuery}) =
      _$ProductSearchImpl;

  String get searchQuery;
  @JsonKey(ignore: true)
  _$$ProductSearchImplCopyWith<_$ProductSearchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetSeriesImplCopyWith<$Res> {
  factory _$$GetSeriesImplCopyWith(
          _$GetSeriesImpl value, $Res Function(_$GetSeriesImpl) then) =
      __$$GetSeriesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String brandName, String categoryType});
}

/// @nodoc
class __$$GetSeriesImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$GetSeriesImpl>
    implements _$$GetSeriesImplCopyWith<$Res> {
  __$$GetSeriesImplCopyWithImpl(
      _$GetSeriesImpl _value, $Res Function(_$GetSeriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? brandName = null,
    Object? categoryType = null,
  }) {
    return _then(_$GetSeriesImpl(
      brandName: null == brandName
          ? _value.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String,
      categoryType: null == categoryType
          ? _value.categoryType
          : categoryType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetSeriesImpl with DiagnosticableTreeMixin implements GetSeries {
  const _$GetSeriesImpl({required this.brandName, required this.categoryType});

  @override
  final String brandName;
  @override
  final String categoryType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.getSeries(brandName: $brandName, categoryType: $categoryType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocEvent.getSeries'))
      ..add(DiagnosticsProperty('brandName', brandName))
      ..add(DiagnosticsProperty('categoryType', categoryType));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetSeriesImpl &&
            (identical(other.brandName, brandName) ||
                other.brandName == brandName) &&
            (identical(other.categoryType, categoryType) ||
                other.categoryType == categoryType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, brandName, categoryType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetSeriesImplCopyWith<_$GetSeriesImpl> get copyWith =>
      __$$GetSeriesImplCopyWithImpl<_$GetSeriesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return getSeries(brandName, categoryType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return getSeries?.call(brandName, categoryType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (getSeries != null) {
      return getSeries(brandName, categoryType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return getSeries(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return getSeries?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (getSeries != null) {
      return getSeries(this);
    }
    return orElse();
  }
}

abstract class GetSeries implements CategoryBlocEvent {
  const factory GetSeries(
      {required final String brandName,
      required final String categoryType}) = _$GetSeriesImpl;

  String get brandName;
  String get categoryType;
  @JsonKey(ignore: true)
  _$$GetSeriesImplCopyWith<_$GetSeriesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetProductbasedOnCategoryAndBrandImplCopyWith<$Res> {
  factory _$$GetProductbasedOnCategoryAndBrandImplCopyWith(
          _$GetProductbasedOnCategoryAndBrandImpl value,
          $Res Function(_$GetProductbasedOnCategoryAndBrandImpl) then) =
      __$$GetProductbasedOnCategoryAndBrandImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String category, String brand});
}

/// @nodoc
class __$$GetProductbasedOnCategoryAndBrandImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res,
        _$GetProductbasedOnCategoryAndBrandImpl>
    implements _$$GetProductbasedOnCategoryAndBrandImplCopyWith<$Res> {
  __$$GetProductbasedOnCategoryAndBrandImplCopyWithImpl(
      _$GetProductbasedOnCategoryAndBrandImpl _value,
      $Res Function(_$GetProductbasedOnCategoryAndBrandImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? category = null,
    Object? brand = null,
  }) {
    return _then(_$GetProductbasedOnCategoryAndBrandImpl(
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      brand: null == brand
          ? _value.brand
          : brand // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetProductbasedOnCategoryAndBrandImpl
    with DiagnosticableTreeMixin
    implements GetProductbasedOnCategoryAndBrand {
  const _$GetProductbasedOnCategoryAndBrandImpl(
      {required this.category, required this.brand});

  @override
  final String category;
  @override
  final String brand;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.getProductbasedOnCategoryAndBrand(category: $category, brand: $brand)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'CategoryBlocEvent.getProductbasedOnCategoryAndBrand'))
      ..add(DiagnosticsProperty('category', category))
      ..add(DiagnosticsProperty('brand', brand));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetProductbasedOnCategoryAndBrandImpl &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.brand, brand) || other.brand == brand));
  }

  @override
  int get hashCode => Object.hash(runtimeType, category, brand);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetProductbasedOnCategoryAndBrandImplCopyWith<
          _$GetProductbasedOnCategoryAndBrandImpl>
      get copyWith => __$$GetProductbasedOnCategoryAndBrandImplCopyWithImpl<
          _$GetProductbasedOnCategoryAndBrandImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return getProductbasedOnCategoryAndBrand(category, brand);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return getProductbasedOnCategoryAndBrand?.call(category, brand);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (getProductbasedOnCategoryAndBrand != null) {
      return getProductbasedOnCategoryAndBrand(category, brand);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return getProductbasedOnCategoryAndBrand(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return getProductbasedOnCategoryAndBrand?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (getProductbasedOnCategoryAndBrand != null) {
      return getProductbasedOnCategoryAndBrand(this);
    }
    return orElse();
  }
}

abstract class GetProductbasedOnCategoryAndBrand implements CategoryBlocEvent {
  const factory GetProductbasedOnCategoryAndBrand(
      {required final String category,
      required final String brand}) = _$GetProductbasedOnCategoryAndBrandImpl;

  String get category;
  String get brand;
  @JsonKey(ignore: true)
  _$$GetProductbasedOnCategoryAndBrandImplCopyWith<
          _$GetProductbasedOnCategoryAndBrandImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetModelsImplCopyWith<$Res> {
  factory _$$GetModelsImplCopyWith(
          _$GetModelsImpl value, $Res Function(_$GetModelsImpl) then) =
      __$$GetModelsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String categoryType, String brandName, String seriesName});
}

/// @nodoc
class __$$GetModelsImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$GetModelsImpl>
    implements _$$GetModelsImplCopyWith<$Res> {
  __$$GetModelsImplCopyWithImpl(
      _$GetModelsImpl _value, $Res Function(_$GetModelsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? categoryType = null,
    Object? brandName = null,
    Object? seriesName = null,
  }) {
    return _then(_$GetModelsImpl(
      categoryType: null == categoryType
          ? _value.categoryType
          : categoryType // ignore: cast_nullable_to_non_nullable
              as String,
      brandName: null == brandName
          ? _value.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String,
      seriesName: null == seriesName
          ? _value.seriesName
          : seriesName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetModelsImpl with DiagnosticableTreeMixin implements GetModels {
  const _$GetModelsImpl(
      {required this.categoryType,
      required this.brandName,
      required this.seriesName});

  @override
  final String categoryType;
  @override
  final String brandName;
  @override
  final String seriesName;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.getModels(categoryType: $categoryType, brandName: $brandName, seriesName: $seriesName)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocEvent.getModels'))
      ..add(DiagnosticsProperty('categoryType', categoryType))
      ..add(DiagnosticsProperty('brandName', brandName))
      ..add(DiagnosticsProperty('seriesName', seriesName));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetModelsImpl &&
            (identical(other.categoryType, categoryType) ||
                other.categoryType == categoryType) &&
            (identical(other.brandName, brandName) ||
                other.brandName == brandName) &&
            (identical(other.seriesName, seriesName) ||
                other.seriesName == seriesName));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, categoryType, brandName, seriesName);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetModelsImplCopyWith<_$GetModelsImpl> get copyWith =>
      __$$GetModelsImplCopyWithImpl<_$GetModelsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return getModels(categoryType, brandName, seriesName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return getModels?.call(categoryType, brandName, seriesName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (getModels != null) {
      return getModels(categoryType, brandName, seriesName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return getModels(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return getModels?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (getModels != null) {
      return getModels(this);
    }
    return orElse();
  }
}

abstract class GetModels implements CategoryBlocEvent {
  const factory GetModels(
      {required final String categoryType,
      required final String brandName,
      required final String seriesName}) = _$GetModelsImpl;

  String get categoryType;
  String get brandName;
  String get seriesName;
  @JsonKey(ignore: true)
  _$$GetModelsImplCopyWith<_$GetModelsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetVarientsImplCopyWith<$Res> {
  factory _$$GetVarientsImplCopyWith(
          _$GetVarientsImpl value, $Res Function(_$GetVarientsImpl) then) =
      __$$GetVarientsImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String categoryType, String brandName, String seriesName, String model});
}

/// @nodoc
class __$$GetVarientsImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$GetVarientsImpl>
    implements _$$GetVarientsImplCopyWith<$Res> {
  __$$GetVarientsImplCopyWithImpl(
      _$GetVarientsImpl _value, $Res Function(_$GetVarientsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? categoryType = null,
    Object? brandName = null,
    Object? seriesName = null,
    Object? model = null,
  }) {
    return _then(_$GetVarientsImpl(
      categoryType: null == categoryType
          ? _value.categoryType
          : categoryType // ignore: cast_nullable_to_non_nullable
              as String,
      brandName: null == brandName
          ? _value.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String,
      seriesName: null == seriesName
          ? _value.seriesName
          : seriesName // ignore: cast_nullable_to_non_nullable
              as String,
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetVarientsImpl with DiagnosticableTreeMixin implements GetVarients {
  const _$GetVarientsImpl(
      {required this.categoryType,
      required this.brandName,
      required this.seriesName,
      required this.model});

  @override
  final String categoryType;
  @override
  final String brandName;
  @override
  final String seriesName;
  @override
  final String model;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.getVarients(categoryType: $categoryType, brandName: $brandName, seriesName: $seriesName, model: $model)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocEvent.getVarients'))
      ..add(DiagnosticsProperty('categoryType', categoryType))
      ..add(DiagnosticsProperty('brandName', brandName))
      ..add(DiagnosticsProperty('seriesName', seriesName))
      ..add(DiagnosticsProperty('model', model));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetVarientsImpl &&
            (identical(other.categoryType, categoryType) ||
                other.categoryType == categoryType) &&
            (identical(other.brandName, brandName) ||
                other.brandName == brandName) &&
            (identical(other.seriesName, seriesName) ||
                other.seriesName == seriesName) &&
            (identical(other.model, model) || other.model == model));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, categoryType, brandName, seriesName, model);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetVarientsImplCopyWith<_$GetVarientsImpl> get copyWith =>
      __$$GetVarientsImplCopyWithImpl<_$GetVarientsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return getVarients(categoryType, brandName, seriesName, model);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return getVarients?.call(categoryType, brandName, seriesName, model);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (getVarients != null) {
      return getVarients(categoryType, brandName, seriesName, model);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return getVarients(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return getVarients?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (getVarients != null) {
      return getVarients(this);
    }
    return orElse();
  }
}

abstract class GetVarients implements CategoryBlocEvent {
  const factory GetVarients(
      {required final String categoryType,
      required final String brandName,
      required final String seriesName,
      required final String model}) = _$GetVarientsImpl;

  String get categoryType;
  String get brandName;
  String get seriesName;
  String get model;
  @JsonKey(ignore: true)
  _$$GetVarientsImplCopyWith<_$GetVarientsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClearImplCopyWith<$Res> {
  factory _$$ClearImplCopyWith(
          _$ClearImpl value, $Res Function(_$ClearImpl) then) =
      __$$ClearImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClearImplCopyWithImpl<$Res>
    extends _$CategoryBlocEventCopyWithImpl<$Res, _$ClearImpl>
    implements _$$ClearImplCopyWith<$Res> {
  __$$ClearImplCopyWithImpl(
      _$ClearImpl _value, $Res Function(_$ClearImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClearImpl with DiagnosticableTreeMixin implements Clear {
  const _$ClearImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocEvent.clear()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'CategoryBlocEvent.clear'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClearImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllCategory,
    required TResult Function(bool isLoad, String? categoryType)
        getSingleCategoryBrands,
    required TResult Function(String searchQuery) brandSearch,
    required TResult Function(String searchQuery) seriesSearch,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getProducts,
    required TResult Function(String searchQuery) productSearch,
    required TResult Function(String brandName, String categoryType) getSeries,
    required TResult Function(String category, String brand)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(
            String categoryType, String brandName, String seriesName)
        getModels,
    required TResult Function(String categoryType, String brandName,
            String seriesName, String model)
        getVarients,
    required TResult Function() clear,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getAllCategory,
    TResult? Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult? Function(String searchQuery)? brandSearch,
    TResult? Function(String searchQuery)? seriesSearch,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult? Function(String searchQuery)? productSearch,
    TResult? Function(String brandName, String categoryType)? getSeries,
    TResult? Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult? Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult? Function()? clear,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllCategory,
    TResult Function(bool isLoad, String? categoryType)?
        getSingleCategoryBrands,
    TResult Function(String searchQuery)? brandSearch,
    TResult Function(String searchQuery)? seriesSearch,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getProducts,
    TResult Function(String searchQuery)? productSearch,
    TResult Function(String brandName, String categoryType)? getSeries,
    TResult Function(String category, String brand)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(String categoryType, String brandName, String seriesName)?
        getModels,
    TResult Function(String categoryType, String brandName, String seriesName,
            String model)?
        getVarients,
    TResult Function()? clear,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetAllCategory value) getAllCategory,
    required TResult Function(GetSingleCategoryBrands value)
        getSingleCategoryBrands,
    required TResult Function(BrandSearch value) brandSearch,
    required TResult Function(SeriesSearch value) seriesSearch,
    required TResult Function(GetProducts value) getProducts,
    required TResult Function(ProductSearch value) productSearch,
    required TResult Function(GetSeries value) getSeries,
    required TResult Function(GetProductbasedOnCategoryAndBrand value)
        getProductbasedOnCategoryAndBrand,
    required TResult Function(GetModels value) getModels,
    required TResult Function(GetVarients value) getVarients,
    required TResult Function(Clear value) clear,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(GetAllCategory value)? getAllCategory,
    TResult? Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult? Function(BrandSearch value)? brandSearch,
    TResult? Function(SeriesSearch value)? seriesSearch,
    TResult? Function(GetProducts value)? getProducts,
    TResult? Function(ProductSearch value)? productSearch,
    TResult? Function(GetSeries value)? getSeries,
    TResult? Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult? Function(GetModels value)? getModels,
    TResult? Function(GetVarients value)? getVarients,
    TResult? Function(Clear value)? clear,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetAllCategory value)? getAllCategory,
    TResult Function(GetSingleCategoryBrands value)? getSingleCategoryBrands,
    TResult Function(BrandSearch value)? brandSearch,
    TResult Function(SeriesSearch value)? seriesSearch,
    TResult Function(GetProducts value)? getProducts,
    TResult Function(ProductSearch value)? productSearch,
    TResult Function(GetSeries value)? getSeries,
    TResult Function(GetProductbasedOnCategoryAndBrand value)?
        getProductbasedOnCategoryAndBrand,
    TResult Function(GetModels value)? getModels,
    TResult Function(GetVarients value)? getVarients,
    TResult Function(Clear value)? clear,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class Clear implements CategoryBlocEvent {
  const factory Clear() = _$ClearImpl;
}

/// @nodoc
mixin _$CategoryBlocState {
  bool get isLoading => throw _privateConstructorUsedError;
  bool get hasError => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  bool? get isPro => throw _privateConstructorUsedError;
  String? get selectedProduct => throw _privateConstructorUsedError;
  SingleCategoryBrandsResponceModel? get getSingleCategoryResponce =>
      throw _privateConstructorUsedError;
  GetProductsRespoceModel? get getProductsResponceModel =>
      throw _privateConstructorUsedError;
  List<String>? get models => throw _privateConstructorUsedError;
  List<String> get varients => throw _privateConstructorUsedError;
  Product? get product => throw _privateConstructorUsedError;
  List<Brands>? get filteredBrands => throw _privateConstructorUsedError;
  List<String>? get filteredSeries => throw _privateConstructorUsedError;
  List<Product>? get filteredProducts => throw _privateConstructorUsedError;
  String? get selectedModel => throw _privateConstructorUsedError;
  String? get selctedVerient => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CategoryBlocStateCopyWith<CategoryBlocState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CategoryBlocStateCopyWith<$Res> {
  factory $CategoryBlocStateCopyWith(
          CategoryBlocState value, $Res Function(CategoryBlocState) then) =
      _$CategoryBlocStateCopyWithImpl<$Res, CategoryBlocState>;
  @useResult
  $Res call(
      {bool isLoading,
      bool hasError,
      String? message,
      bool? isPro,
      String? selectedProduct,
      SingleCategoryBrandsResponceModel? getSingleCategoryResponce,
      GetProductsRespoceModel? getProductsResponceModel,
      List<String>? models,
      List<String> varients,
      Product? product,
      List<Brands>? filteredBrands,
      List<String>? filteredSeries,
      List<Product>? filteredProducts,
      String? selectedModel,
      String? selctedVerient});
}

/// @nodoc
class _$CategoryBlocStateCopyWithImpl<$Res, $Val extends CategoryBlocState>
    implements $CategoryBlocStateCopyWith<$Res> {
  _$CategoryBlocStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? hasError = null,
    Object? message = freezed,
    Object? isPro = freezed,
    Object? selectedProduct = freezed,
    Object? getSingleCategoryResponce = freezed,
    Object? getProductsResponceModel = freezed,
    Object? models = freezed,
    Object? varients = null,
    Object? product = freezed,
    Object? filteredBrands = freezed,
    Object? filteredSeries = freezed,
    Object? filteredProducts = freezed,
    Object? selectedModel = freezed,
    Object? selctedVerient = freezed,
  }) {
    return _then(_value.copyWith(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      hasError: null == hasError
          ? _value.hasError
          : hasError // ignore: cast_nullable_to_non_nullable
              as bool,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      isPro: freezed == isPro
          ? _value.isPro
          : isPro // ignore: cast_nullable_to_non_nullable
              as bool?,
      selectedProduct: freezed == selectedProduct
          ? _value.selectedProduct
          : selectedProduct // ignore: cast_nullable_to_non_nullable
              as String?,
      getSingleCategoryResponce: freezed == getSingleCategoryResponce
          ? _value.getSingleCategoryResponce
          : getSingleCategoryResponce // ignore: cast_nullable_to_non_nullable
              as SingleCategoryBrandsResponceModel?,
      getProductsResponceModel: freezed == getProductsResponceModel
          ? _value.getProductsResponceModel
          : getProductsResponceModel // ignore: cast_nullable_to_non_nullable
              as GetProductsRespoceModel?,
      models: freezed == models
          ? _value.models
          : models // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      varients: null == varients
          ? _value.varients
          : varients // ignore: cast_nullable_to_non_nullable
              as List<String>,
      product: freezed == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as Product?,
      filteredBrands: freezed == filteredBrands
          ? _value.filteredBrands
          : filteredBrands // ignore: cast_nullable_to_non_nullable
              as List<Brands>?,
      filteredSeries: freezed == filteredSeries
          ? _value.filteredSeries
          : filteredSeries // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      filteredProducts: freezed == filteredProducts
          ? _value.filteredProducts
          : filteredProducts // ignore: cast_nullable_to_non_nullable
              as List<Product>?,
      selectedModel: freezed == selectedModel
          ? _value.selectedModel
          : selectedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      selctedVerient: freezed == selctedVerient
          ? _value.selctedVerient
          : selctedVerient // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res>
    implements $CategoryBlocStateCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isLoading,
      bool hasError,
      String? message,
      bool? isPro,
      String? selectedProduct,
      SingleCategoryBrandsResponceModel? getSingleCategoryResponce,
      GetProductsRespoceModel? getProductsResponceModel,
      List<String>? models,
      List<String> varients,
      Product? product,
      List<Brands>? filteredBrands,
      List<String>? filteredSeries,
      List<Product>? filteredProducts,
      String? selectedModel,
      String? selctedVerient});
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$CategoryBlocStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? hasError = null,
    Object? message = freezed,
    Object? isPro = freezed,
    Object? selectedProduct = freezed,
    Object? getSingleCategoryResponce = freezed,
    Object? getProductsResponceModel = freezed,
    Object? models = freezed,
    Object? varients = null,
    Object? product = freezed,
    Object? filteredBrands = freezed,
    Object? filteredSeries = freezed,
    Object? filteredProducts = freezed,
    Object? selectedModel = freezed,
    Object? selctedVerient = freezed,
  }) {
    return _then(_$InitialImpl(
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      hasError: null == hasError
          ? _value.hasError
          : hasError // ignore: cast_nullable_to_non_nullable
              as bool,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      isPro: freezed == isPro
          ? _value.isPro
          : isPro // ignore: cast_nullable_to_non_nullable
              as bool?,
      selectedProduct: freezed == selectedProduct
          ? _value.selectedProduct
          : selectedProduct // ignore: cast_nullable_to_non_nullable
              as String?,
      getSingleCategoryResponce: freezed == getSingleCategoryResponce
          ? _value.getSingleCategoryResponce
          : getSingleCategoryResponce // ignore: cast_nullable_to_non_nullable
              as SingleCategoryBrandsResponceModel?,
      getProductsResponceModel: freezed == getProductsResponceModel
          ? _value.getProductsResponceModel
          : getProductsResponceModel // ignore: cast_nullable_to_non_nullable
              as GetProductsRespoceModel?,
      models: freezed == models
          ? _value._models
          : models // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      varients: null == varients
          ? _value._varients
          : varients // ignore: cast_nullable_to_non_nullable
              as List<String>,
      product: freezed == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as Product?,
      filteredBrands: freezed == filteredBrands
          ? _value._filteredBrands
          : filteredBrands // ignore: cast_nullable_to_non_nullable
              as List<Brands>?,
      filteredSeries: freezed == filteredSeries
          ? _value._filteredSeries
          : filteredSeries // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      filteredProducts: freezed == filteredProducts
          ? _value._filteredProducts
          : filteredProducts // ignore: cast_nullable_to_non_nullable
              as List<Product>?,
      selectedModel: freezed == selectedModel
          ? _value.selectedModel
          : selectedModel // ignore: cast_nullable_to_non_nullable
              as String?,
      selctedVerient: freezed == selctedVerient
          ? _value.selctedVerient
          : selctedVerient // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InitialImpl with DiagnosticableTreeMixin implements _Initial {
  const _$InitialImpl(
      {required this.isLoading,
      required this.hasError,
      this.message,
      this.isPro,
      this.selectedProduct,
      this.getSingleCategoryResponce,
      this.getProductsResponceModel,
      final List<String>? models,
      required final List<String> varients,
      this.product,
      final List<Brands>? filteredBrands,
      final List<String>? filteredSeries,
      final List<Product>? filteredProducts,
      this.selectedModel,
      this.selctedVerient})
      : _models = models,
        _varients = varients,
        _filteredBrands = filteredBrands,
        _filteredSeries = filteredSeries,
        _filteredProducts = filteredProducts;

  @override
  final bool isLoading;
  @override
  final bool hasError;
  @override
  final String? message;
  @override
  final bool? isPro;
  @override
  final String? selectedProduct;
  @override
  final SingleCategoryBrandsResponceModel? getSingleCategoryResponce;
  @override
  final GetProductsRespoceModel? getProductsResponceModel;
  final List<String>? _models;
  @override
  List<String>? get models {
    final value = _models;
    if (value == null) return null;
    if (_models is EqualUnmodifiableListView) return _models;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String> _varients;
  @override
  List<String> get varients {
    if (_varients is EqualUnmodifiableListView) return _varients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_varients);
  }

  @override
  final Product? product;
  final List<Brands>? _filteredBrands;
  @override
  List<Brands>? get filteredBrands {
    final value = _filteredBrands;
    if (value == null) return null;
    if (_filteredBrands is EqualUnmodifiableListView) return _filteredBrands;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _filteredSeries;
  @override
  List<String>? get filteredSeries {
    final value = _filteredSeries;
    if (value == null) return null;
    if (_filteredSeries is EqualUnmodifiableListView) return _filteredSeries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Product>? _filteredProducts;
  @override
  List<Product>? get filteredProducts {
    final value = _filteredProducts;
    if (value == null) return null;
    if (_filteredProducts is EqualUnmodifiableListView)
      return _filteredProducts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? selectedModel;
  @override
  final String? selctedVerient;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CategoryBlocState(isLoading: $isLoading, hasError: $hasError, message: $message, isPro: $isPro, selectedProduct: $selectedProduct, getSingleCategoryResponce: $getSingleCategoryResponce, getProductsResponceModel: $getProductsResponceModel, models: $models, varients: $varients, product: $product, filteredBrands: $filteredBrands, filteredSeries: $filteredSeries, filteredProducts: $filteredProducts, selectedModel: $selectedModel, selctedVerient: $selctedVerient)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CategoryBlocState'))
      ..add(DiagnosticsProperty('isLoading', isLoading))
      ..add(DiagnosticsProperty('hasError', hasError))
      ..add(DiagnosticsProperty('message', message))
      ..add(DiagnosticsProperty('isPro', isPro))
      ..add(DiagnosticsProperty('selectedProduct', selectedProduct))
      ..add(DiagnosticsProperty(
          'getSingleCategoryResponce', getSingleCategoryResponce))
      ..add(DiagnosticsProperty(
          'getProductsResponceModel', getProductsResponceModel))
      ..add(DiagnosticsProperty('models', models))
      ..add(DiagnosticsProperty('varients', varients))
      ..add(DiagnosticsProperty('product', product))
      ..add(DiagnosticsProperty('filteredBrands', filteredBrands))
      ..add(DiagnosticsProperty('filteredSeries', filteredSeries))
      ..add(DiagnosticsProperty('filteredProducts', filteredProducts))
      ..add(DiagnosticsProperty('selectedModel', selectedModel))
      ..add(DiagnosticsProperty('selctedVerient', selctedVerient));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.hasError, hasError) ||
                other.hasError == hasError) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.isPro, isPro) || other.isPro == isPro) &&
            (identical(other.selectedProduct, selectedProduct) ||
                other.selectedProduct == selectedProduct) &&
            (identical(other.getSingleCategoryResponce,
                    getSingleCategoryResponce) ||
                other.getSingleCategoryResponce == getSingleCategoryResponce) &&
            (identical(
                    other.getProductsResponceModel, getProductsResponceModel) ||
                other.getProductsResponceModel == getProductsResponceModel) &&
            const DeepCollectionEquality().equals(other._models, _models) &&
            const DeepCollectionEquality().equals(other._varients, _varients) &&
            (identical(other.product, product) || other.product == product) &&
            const DeepCollectionEquality()
                .equals(other._filteredBrands, _filteredBrands) &&
            const DeepCollectionEquality()
                .equals(other._filteredSeries, _filteredSeries) &&
            const DeepCollectionEquality()
                .equals(other._filteredProducts, _filteredProducts) &&
            (identical(other.selectedModel, selectedModel) ||
                other.selectedModel == selectedModel) &&
            (identical(other.selctedVerient, selctedVerient) ||
                other.selctedVerient == selctedVerient));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoading,
      hasError,
      message,
      isPro,
      selectedProduct,
      getSingleCategoryResponce,
      getProductsResponceModel,
      const DeepCollectionEquality().hash(_models),
      const DeepCollectionEquality().hash(_varients),
      product,
      const DeepCollectionEquality().hash(_filteredBrands),
      const DeepCollectionEquality().hash(_filteredSeries),
      const DeepCollectionEquality().hash(_filteredProducts),
      selectedModel,
      selctedVerient);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);
}

abstract class _Initial implements CategoryBlocState {
  const factory _Initial(
      {required final bool isLoading,
      required final bool hasError,
      final String? message,
      final bool? isPro,
      final String? selectedProduct,
      final SingleCategoryBrandsResponceModel? getSingleCategoryResponce,
      final GetProductsRespoceModel? getProductsResponceModel,
      final List<String>? models,
      required final List<String> varients,
      final Product? product,
      final List<Brands>? filteredBrands,
      final List<String>? filteredSeries,
      final List<Product>? filteredProducts,
      final String? selectedModel,
      final String? selctedVerient}) = _$InitialImpl;

  @override
  bool get isLoading;
  @override
  bool get hasError;
  @override
  String? get message;
  @override
  bool? get isPro;
  @override
  String? get selectedProduct;
  @override
  SingleCategoryBrandsResponceModel? get getSingleCategoryResponce;
  @override
  GetProductsRespoceModel? get getProductsResponceModel;
  @override
  List<String>? get models;
  @override
  List<String> get varients;
  @override
  Product? get product;
  @override
  List<Brands>? get filteredBrands;
  @override
  List<String>? get filteredSeries;
  @override
  List<Product>? get filteredProducts;
  @override
  String? get selectedModel;
  @override
  String? get selctedVerient;
  @override
  @JsonKey(ignore: true)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
